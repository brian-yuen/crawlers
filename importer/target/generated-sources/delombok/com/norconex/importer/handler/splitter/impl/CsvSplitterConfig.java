// Generated by delombok at Fri Mar 08 16:25:39 MST 2024
/* Copyright 2014-2023 Norconex Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.norconex.importer.handler.splitter.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import com.norconex.commons.lang.collection.CollectionUtil;
import com.norconex.commons.lang.text.TextMatcher;
import com.norconex.importer.handler.splitter.BaseDocumentSplitterConfig;

/**
 * <p>Split files with Coma-Separated values (or any other characters, like tab)
 * into one document per line.</p>
 *
 * <p>Can be used both as a pre-parse (text documents) or post-parse handler
 * documents.</p>
 *
 * {@nx.xml.usage
 * <handler class="com.norconex.importer.handler.splitter.impl.CsvSplitter"
 *          separatorCharacter=""
 *          quoteCharacter=""
 *          escapeCharacter=""
 *          useFirstRowAsFields="(false|true)"
 *          linesToSkip="(integer)"
 *          referenceColumn="(column name or position from 1)"
 *          contentColumns="(csv list of column/position to use as content)" >
 *   {@nx.include com.norconex.importer.handler.AbstractImporterHandler#restrictTo}
 * </handler>
 * }
 *
 * {@nx.xml.example
 * <handler class="CsvSplitter"
 *     separatorCharacter=","
 *     quoteCharacter="'"
 *     escapeCharacter="\"
 *     useFirstRowAsFields="true"
 *     linesToSkip="0"
 *     referenceColumn="clientId"
 *     contentColumns="orgDesc" />
 * }
 * <p>
 * Given this sample CSV file content...
 * </p>
 * <pre>
 * 'clientId','clientName','clientOrg','orgDesc'
 * '123','Joe Dalton','ACME Inc.','Organization\'s description'
 * '345','Avrel Dalton','Daisy Town','Another one'
 * </pre>
 * <p>
 * ... the above example will split the file into two documents (one for each
 * row after the header row):
 * </p>
 */
@SuppressWarnings("javadoc")
public class CsvSplitterConfig extends BaseDocumentSplitterConfig {
    public static final char DEFAULT_SEPARATOR_CHARACTER = ',';
    public static final char DEFAULT_QUOTE_CHARACTER = '\"';
    public static final char DEFAULT_ESCAPE_CHARACTER = '\\';
    /**
     * Matcher of one or more fields to use as the source of content to split
     * into new documents, instead of the original document content.
     * @param fieldMatcher field matcher
     */
    private final TextMatcher fieldMatcher = new TextMatcher();

    public CsvSplitterConfig setFieldMatcher(TextMatcher fieldMatcher) {
        this.fieldMatcher.copyFrom(fieldMatcher);
        return this;
    }

    /**
     * The value-separator character. Default is the comma character (,).
     */
    private char separatorCharacter = DEFAULT_SEPARATOR_CHARACTER;
    /**
     * The value's surrounding quotes character.  Default is the
     * double-quote character (").
     */
    private char quoteCharacter = DEFAULT_QUOTE_CHARACTER;
    /**
     * The escape character.  Default is the backslash character (\).
     */
    private char escapeCharacter = DEFAULT_ESCAPE_CHARACTER;
    /**
     * Whether to use the first row as field names for values.
     * Default is <code>false</code>.
     */
    private boolean useFirstRowAsFields;
    /**
     * The number of lines to skip before starting to parse lines.
     * Default is <code>0</code>.
     */
    private int linesToSkip;
    /**
     * The column containing the unique document reference. Can be either
     * a column name or position, starting at <code>1</code>.
     */
    private String referenceColumn;
    private final List<String> contentColumns = new ArrayList<>();

    /**
     * One or several columns containing the text to be considered as
     * the document "content".
     * @return content columns
     */
    public List<String> getContentColumns() {
        return Collections.unmodifiableList(contentColumns);
    }

    /**
     * One or several columns containing the text to be considered as
     * the document "content".
     * @param contentColumns content columns
     * @return this instance
     */
    public CsvSplitterConfig setContentColumns(List<String> contentColumns) {
        CollectionUtil.setAll(this.contentColumns, contentColumns);
        return this;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public CsvSplitterConfig() {
    }

    /**
     * Matcher of one or more fields to use as the source of content to split
     * into new documents, instead of the original document content.
     * @return field matcher
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public TextMatcher getFieldMatcher() {
        return this.fieldMatcher;
    }

    /**
     * The value-separator character. Default is the comma character (,).
     * @return value-separator character
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public char getSeparatorCharacter() {
        return this.separatorCharacter;
    }

    /**
     * The value's surrounding quotes character.  Default is the
     * double-quote character (").
     * @return value's surrounding quotes character
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public char getQuoteCharacter() {
        return this.quoteCharacter;
    }

    /**
     * The escape character.  Default is the backslash character (\).
     * @return escape character
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public char getEscapeCharacter() {
        return this.escapeCharacter;
    }

    /**
     * Whether to use the first row as field names for values.
     * Default is <code>false</code>.
     * @return <code>true</code> if using first row as field names.
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public boolean isUseFirstRowAsFields() {
        return this.useFirstRowAsFields;
    }

    /**
     * The number of lines to skip before starting to parse lines.
     * Default is <code>0</code>.
     * @return the number of lines to skip
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public int getLinesToSkip() {
        return this.linesToSkip;
    }

    /**
     * The column containing the unique document reference. Can be either
     * a column name or position, starting at <code>1</code>.
     * @return column name or position
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public String getReferenceColumn() {
        return this.referenceColumn;
    }

    /**
     * The value-separator character. Default is the comma character (,).
     * @param separatorCharacter value-separator character
     * @return {@code this}.
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public CsvSplitterConfig setSeparatorCharacter(final char separatorCharacter) {
        this.separatorCharacter = separatorCharacter;
        return this;
    }

    /**
     * The value's surrounding quotes character.  Default is the
     * double-quote character (").
     * @param quoteCharacter value's surrounding quotes character
     * @return {@code this}.
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public CsvSplitterConfig setQuoteCharacter(final char quoteCharacter) {
        this.quoteCharacter = quoteCharacter;
        return this;
    }

    /**
     * The escape character.  Default is the backslash character (\).
     * @param escapeCharacter escape character
     * @return {@code this}.
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public CsvSplitterConfig setEscapeCharacter(final char escapeCharacter) {
        this.escapeCharacter = escapeCharacter;
        return this;
    }

    /**
     * Whether to use the first row as field names for values.
     * Default is <code>false</code>.
     * @param useFirstRowAsFields <code>true</code> if using first row as
     *        field names
     * @return {@code this}.
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public CsvSplitterConfig setUseFirstRowAsFields(final boolean useFirstRowAsFields) {
        this.useFirstRowAsFields = useFirstRowAsFields;
        return this;
    }

    /**
     * The number of lines to skip before starting to parse lines.
     * Default is <code>0</code>.
     * @param linesToSkip the number of lines to skip
     * @return {@code this}.
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public CsvSplitterConfig setLinesToSkip(final int linesToSkip) {
        this.linesToSkip = linesToSkip;
        return this;
    }

    /**
     * The column containing the unique document reference. Can be either
     * a column name or position, starting at <code>1</code>.
     * @param referenceColumn column name or position
     * @return {@code this}.
     */
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public CsvSplitterConfig setReferenceColumn(final String referenceColumn) {
        this.referenceColumn = referenceColumn;
        return this;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public boolean equals(final java.lang.Object o) {
        if (o == this) return true;
        if (!(o instanceof CsvSplitterConfig)) return false;
        final CsvSplitterConfig other = (CsvSplitterConfig) o;
        if (!other.canEqual((java.lang.Object) this)) return false;
        if (!super.equals(o)) return false;
        if (this.getSeparatorCharacter() != other.getSeparatorCharacter()) return false;
        if (this.getQuoteCharacter() != other.getQuoteCharacter()) return false;
        if (this.getEscapeCharacter() != other.getEscapeCharacter()) return false;
        if (this.isUseFirstRowAsFields() != other.isUseFirstRowAsFields()) return false;
        if (this.getLinesToSkip() != other.getLinesToSkip()) return false;
        final java.lang.Object this$fieldMatcher = this.getFieldMatcher();
        final java.lang.Object other$fieldMatcher = other.getFieldMatcher();
        if (this$fieldMatcher == null ? other$fieldMatcher != null : !this$fieldMatcher.equals(other$fieldMatcher)) return false;
        final java.lang.Object this$referenceColumn = this.getReferenceColumn();
        final java.lang.Object other$referenceColumn = other.getReferenceColumn();
        if (this$referenceColumn == null ? other$referenceColumn != null : !this$referenceColumn.equals(other$referenceColumn)) return false;
        final java.lang.Object this$contentColumns = this.getContentColumns();
        final java.lang.Object other$contentColumns = other.getContentColumns();
        if (this$contentColumns == null ? other$contentColumns != null : !this$contentColumns.equals(other$contentColumns)) return false;
        return true;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    protected boolean canEqual(final java.lang.Object other) {
        return other instanceof CsvSplitterConfig;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public int hashCode() {
        final int PRIME = 59;
        int result = super.hashCode();
        result = result * PRIME + this.getSeparatorCharacter();
        result = result * PRIME + this.getQuoteCharacter();
        result = result * PRIME + this.getEscapeCharacter();
        result = result * PRIME + (this.isUseFirstRowAsFields() ? 79 : 97);
        result = result * PRIME + this.getLinesToSkip();
        final java.lang.Object $fieldMatcher = this.getFieldMatcher();
        result = result * PRIME + ($fieldMatcher == null ? 43 : $fieldMatcher.hashCode());
        final java.lang.Object $referenceColumn = this.getReferenceColumn();
        result = result * PRIME + ($referenceColumn == null ? 43 : $referenceColumn.hashCode());
        final java.lang.Object $contentColumns = this.getContentColumns();
        result = result * PRIME + ($contentColumns == null ? 43 : $contentColumns.hashCode());
        return result;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public java.lang.String toString() {
        return "CsvSplitterConfig(super=" + super.toString() + ", fieldMatcher=" + this.getFieldMatcher() + ", separatorCharacter=" + this.getSeparatorCharacter() + ", quoteCharacter=" + this.getQuoteCharacter() + ", escapeCharacter=" + this.getEscapeCharacter() + ", useFirstRowAsFields=" + this.isUseFirstRowAsFields() + ", linesToSkip=" + this.getLinesToSkip() + ", referenceColumn=" + this.getReferenceColumn() + ", contentColumns=" + this.getContentColumns() + ")";
    }
}
