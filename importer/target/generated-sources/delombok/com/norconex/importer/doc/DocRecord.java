// Generated by delombok at Fri Mar 08 16:25:39 MST 2024
/* Copyright 2020-2023 Norconex Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.norconex.importer.doc;

import java.io.Serializable;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.apache.commons.lang3.builder.ToStringExclude;
import com.norconex.commons.lang.bean.BeanUtil;
import com.norconex.commons.lang.collection.CollectionUtil;
import com.norconex.commons.lang.file.ContentType;
import lombok.NonNull;
//@JsonAutoDetect(
//    getterVisibility = JsonAutoDetect.Visibility.NONE,
//    isGetterVisibility = JsonAutoDetect.Visibility.NONE
//)
/**
 * Important information about a document that has specific meaning and purpose
 * for processing by the Importer and needs to be stored/referenced in a
 * consistent way. In some contexts, a document record is a lightweight,
 * cacheable version of a document ({@link Doc}).
 */
public class DocRecord implements Serializable {
    private static final long serialVersionUID = 1L;
    // DocRecord?
    //TODO DocProperties?  misleading because of Properties
    //TODO DocAttributes?  seems distinct enough.  Use this.
    //MAYBE:
    // - private Locale locale?
    // - create interface IDocInfo?
    // - add parent reference info here???
    // - remove most Properties method and put them here.
    // - track original vs final here (useful for tracking deletions
    //   under a modified reference (and have dynamic committer targets).
    // - make final?
    @NonNull
    private String reference = null;
    private ContentType contentType;
    private Charset charset;
    //MAYBE: remove prefix "embedded" and just keep parent* ?
    // trail of parent references (first one is root/top-level)
//    @ToStringSummary
    @ToStringExclude
    private List<String> embeddedParentReferences = new ArrayList<>();

    //MAYBE: above should just be parentReferences and below should be metadata?
    //MAYBE: add a method toMetadata or "asMetadata" as opposed to have
    // external conversion
    /**
     * Constructor.
     */
    public DocRecord() {
    }

    /**
     * Constructor.
     * @param reference document reference
     */
    public DocRecord(String reference) {
        setReference(reference);
    }

    /**
     * Copy constructor.
     * @param docRecord document details to copy
     */
    public DocRecord(@NonNull DocRecord docRecord) {
        java.util.Objects.requireNonNull(docRecord, "docRecord is marked non-null but is null");
        copyFrom(docRecord);
    }

    public List<String> getEmbeddedParentReferences() {
        return Collections.unmodifiableList(embeddedParentReferences);
    }

    public void setEmbeddedParentReferences(List<String> embeddedParentReferences) {
        CollectionUtil.setAll(this.embeddedParentReferences, embeddedParentReferences);
    }

    public void addEmbeddedParentReference(String embeddedParentReference) {
        embeddedParentReferences.add(embeddedParentReference);
    }

    //MAYBE: use this new method instead of having clone functional
    //  interface on Crawler class.
    public DocRecord withReference(String reference, DocRecord docRecord) {
        var newDocInfo = new DocRecord(docRecord);
        newDocInfo.setReference(reference);
        return newDocInfo;
    }

    public void copyTo(DocRecord target) {
        BeanUtil.copyProperties(target, this);
    }

    public void copyFrom(DocRecord source) {
        BeanUtil.copyProperties(this, source);
    }

    @NonNull
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public String getReference() {
        return this.reference;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public ContentType getContentType() {
        return this.contentType;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public Charset getCharset() {
        return this.charset;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public void setReference(@NonNull final String reference) {
        java.util.Objects.requireNonNull(reference, "reference is marked non-null but is null");
        this.reference = reference;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public void setContentType(final ContentType contentType) {
        this.contentType = contentType;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public void setCharset(final Charset charset) {
        this.charset = charset;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public boolean equals(final java.lang.Object o) {
        if (o == this) return true;
        if (!(o instanceof DocRecord)) return false;
        final DocRecord other = (DocRecord) o;
        if (!other.canEqual((java.lang.Object) this)) return false;
        final java.lang.Object this$reference = this.getReference();
        final java.lang.Object other$reference = other.getReference();
        if (this$reference == null ? other$reference != null : !this$reference.equals(other$reference)) return false;
        final java.lang.Object this$contentType = this.getContentType();
        final java.lang.Object other$contentType = other.getContentType();
        if (this$contentType == null ? other$contentType != null : !this$contentType.equals(other$contentType)) return false;
        final java.lang.Object this$charset = this.getCharset();
        final java.lang.Object other$charset = other.getCharset();
        if (this$charset == null ? other$charset != null : !this$charset.equals(other$charset)) return false;
        final java.lang.Object this$embeddedParentReferences = this.getEmbeddedParentReferences();
        final java.lang.Object other$embeddedParentReferences = other.getEmbeddedParentReferences();
        if (this$embeddedParentReferences == null ? other$embeddedParentReferences != null : !this$embeddedParentReferences.equals(other$embeddedParentReferences)) return false;
        return true;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    protected boolean canEqual(final java.lang.Object other) {
        return other instanceof DocRecord;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final java.lang.Object $reference = this.getReference();
        result = result * PRIME + ($reference == null ? 43 : $reference.hashCode());
        final java.lang.Object $contentType = this.getContentType();
        result = result * PRIME + ($contentType == null ? 43 : $contentType.hashCode());
        final java.lang.Object $charset = this.getCharset();
        result = result * PRIME + ($charset == null ? 43 : $charset.hashCode());
        final java.lang.Object $embeddedParentReferences = this.getEmbeddedParentReferences();
        result = result * PRIME + ($embeddedParentReferences == null ? 43 : $embeddedParentReferences.hashCode());
        return result;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public java.lang.String toString() {
        return "DocRecord(reference=" + this.getReference() + ", contentType=" + this.getContentType() + ", charset=" + this.getCharset() + ", embeddedParentReferences=" + this.getEmbeddedParentReferences() + ")";
    }
}
