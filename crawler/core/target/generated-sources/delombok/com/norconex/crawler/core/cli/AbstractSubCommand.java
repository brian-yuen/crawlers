// Generated by delombok at Fri Mar 08 16:24:33 MST 2024
/* Copyright 2019-2022 Norconex Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.norconex.crawler.core.cli;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import com.norconex.commons.lang.ExceptionUtil;
import com.norconex.commons.lang.bean.BeanMapper;
import com.norconex.commons.lang.config.ConfigurationLoader;
import com.norconex.crawler.core.session.CrawlSession;
import com.norconex.crawler.core.session.CrawlSessionConfig;
import jakarta.validation.ConstraintViolationException;
import picocli.CommandLine;
import picocli.CommandLine.Model.CommandSpec;
import picocli.CommandLine.Option;
import picocli.CommandLine.ParentCommand;
import picocli.CommandLine.Spec;

/**
 * Base class for sub-commands.
 */
public abstract class AbstractSubCommand implements Callable<Integer> {
    @ParentCommand
    private MainCommand parent;
    @Spec
    private CommandSpec spec;
    @Option(names = {"-c", "-config"}, paramLabel = "FILE", description = "Path to crawl session configuration file.", required = true)
    private Path configFile;
    @Option(names = {"-variables"}, paramLabel = "FILE", description = "Path to variables file.")
    private Path variablesFile;
    @Option(names = {"-crawlers"}, paramLabel = "<crawler>", description = "TO IMPLEMENT: Restrict the command to one or more " + "crawler (comma-separated).", split = ",")
    private final List<String> crawlers = new ArrayList<>();
    private CrawlSession crawlSession;

//    private BeanMapper beanMapper;
    protected void printOut() {
        commandLine().getOut().println();
    }

    protected void printOut(String str) {
        commandLine().getOut().println(str);
    }

    protected void printErr() {
        commandLine().getErr().println();
    }

    protected void printErr(String str) {
        commandLine().getErr().println(str);
    }

    protected CommandLine commandLine() {
        return spec.commandLine();
    }

    protected CrawlSession getCrawlSession() {
        return crawlSession;
    }

    protected BeanMapper getBeanMapper() {
        return parent.getBeanMapper();
    }

    protected CrawlSessionConfig getCrawlSessionConfig() {
        return parent.getCrawlSessionBuilder().crawlSessionConfig();
    }

//    protected BeanMapper getBeanMapper() {
//        return beanMapper;
//    }
    protected abstract void runCommand();

    protected int createCrawlSession() {
        if (getConfigFile() == null || !getConfigFile().toFile().isFile()) {
            printErr("Configuration file does not exist or is not valid: " + getConfigFile().toFile().getAbsolutePath());
            return -1;
        }
//
//        beanMapper = beanMapper();
        var returnValue = configLoader();
        if (returnValue != 0) {
            return returnValue;
        }
        crawlSession = parent.getCrawlSessionBuilder().build();
        return 0;
    }

    @Override
    public Integer call() throws Exception {
        var exitVal = createCrawlSession();
        if (exitVal != 0) {
            return exitVal;
        }
        runCommand();
        return 0;
    }

    private int configLoader() {
        var cfg = getCrawlSessionConfig();
        try {
            ConfigurationLoader.builder().variablesFile(getVariablesFile()).beanMapper(parent.getBeanMapper()).build().toObject(getConfigFile(), cfg);
        } catch (ConstraintViolationException e) {
            if (!e.getConstraintViolations().isEmpty()) {
                printErr();
                printErr(e.getConstraintViolations().size() + " configuration errors detected:");
                printErr();
                e.getConstraintViolations().forEach(cv -> printErr(cv.getMessage()));
                return -1;
            }
        } catch (IOException e) {
            printErr(ExceptionUtil.getFormattedMessages(e));
            return -1;
        }
        return 0;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public boolean equals(final java.lang.Object o) {
        if (o == this) return true;
        if (!(o instanceof AbstractSubCommand)) return false;
        final AbstractSubCommand other = (AbstractSubCommand) o;
        if (!other.canEqual((java.lang.Object) this)) return false;
        final java.lang.Object this$parent = this.parent;
        final java.lang.Object other$parent = other.parent;
        if (this$parent == null ? other$parent != null : !this$parent.equals(other$parent)) return false;
        final java.lang.Object this$spec = this.spec;
        final java.lang.Object other$spec = other.spec;
        if (this$spec == null ? other$spec != null : !this$spec.equals(other$spec)) return false;
        final java.lang.Object this$configFile = this.getConfigFile();
        final java.lang.Object other$configFile = other.getConfigFile();
        if (this$configFile == null ? other$configFile != null : !this$configFile.equals(other$configFile)) return false;
        final java.lang.Object this$variablesFile = this.getVariablesFile();
        final java.lang.Object other$variablesFile = other.getVariablesFile();
        if (this$variablesFile == null ? other$variablesFile != null : !this$variablesFile.equals(other$variablesFile)) return false;
        final java.lang.Object this$crawlers = this.getCrawlers();
        final java.lang.Object other$crawlers = other.getCrawlers();
        if (this$crawlers == null ? other$crawlers != null : !this$crawlers.equals(other$crawlers)) return false;
        final java.lang.Object this$crawlSession = this.getCrawlSession();
        final java.lang.Object other$crawlSession = other.getCrawlSession();
        if (this$crawlSession == null ? other$crawlSession != null : !this$crawlSession.equals(other$crawlSession)) return false;
        return true;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    protected boolean canEqual(final java.lang.Object other) {
        return other instanceof AbstractSubCommand;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final java.lang.Object $parent = this.parent;
        result = result * PRIME + ($parent == null ? 43 : $parent.hashCode());
        final java.lang.Object $spec = this.spec;
        result = result * PRIME + ($spec == null ? 43 : $spec.hashCode());
        final java.lang.Object $configFile = this.getConfigFile();
        result = result * PRIME + ($configFile == null ? 43 : $configFile.hashCode());
        final java.lang.Object $variablesFile = this.getVariablesFile();
        result = result * PRIME + ($variablesFile == null ? 43 : $variablesFile.hashCode());
        final java.lang.Object $crawlers = this.getCrawlers();
        result = result * PRIME + ($crawlers == null ? 43 : $crawlers.hashCode());
        final java.lang.Object $crawlSession = this.getCrawlSession();
        result = result * PRIME + ($crawlSession == null ? 43 : $crawlSession.hashCode());
        return result;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public java.lang.String toString() {
        return "AbstractSubCommand(parent=" + this.parent + ", spec=" + this.spec + ", configFile=" + this.getConfigFile() + ", variablesFile=" + this.getVariablesFile() + ", crawlers=" + this.getCrawlers() + ", crawlSession=" + this.getCrawlSession() + ")";
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public Path getConfigFile() {
        return this.configFile;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public void setConfigFile(final Path configFile) {
        this.configFile = configFile;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public Path getVariablesFile() {
        return this.variablesFile;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public void setVariablesFile(final Path variablesFile) {
        this.variablesFile = variablesFile;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public List<String> getCrawlers() {
        return this.crawlers;
    }
//    //TODO apply crawler defaults....
//
//    //TODO move the crawler-specific BeamMapper initialization out
//    // so it can be used outside file-loading context.
//
//    private BeanMapper beanMapper() {
//        var builder = BeanMapper.builder()
//            //MAYBE: make package configurable? Maybe use java service loaded?
//            .unboundPropertyMapping("crawlerDefaults",
//                    parent.getCrawlSessionBuilder().crawlerConfigClass())
//            .unboundPropertyMapping("crawler",
//                    parent.getCrawlSessionBuilder().crawlerConfigClass())
//            .unboundPropertyMapping("importer", Importer.class);
//
//        registerPolymorpicTypes(builder);
//
//        var beanMapperCustomizer =
//                parent.getCrawlSessionBuilder().beanMapperCustomizer();
//        if (beanMapperCustomizer != null) {
//            beanMapperCustomizer.accept(builder);
//        }
//        return builder.build();
//    }
//
//    private void registerPolymorpicTypes(BeanMapperBuilder builder) {
//        //TODO make scanning path configurable? Like java service loader?
//        // or rely on fully qualified names for non Nx classes? Maybe the latter
//        // is best to avoid name collisions?
//        Predicate<String> predicate = nm -> nm.startsWith("com.norconex.");
//
//        // This one has too many that are not meant to be added as configuration
//        // so we only accept those that are standalone listeners:
//        builder.polymorphicType(EventListener.class,
//                predicate.and(nm -> nm.endsWith("EventListener")));
//        builder.polymorphicType(ReferencesProvider.class, predicate);
//        builder.polymorphicType(DataStoreEngine.class, predicate);
//        builder.polymorphicType(ReferenceFilter.class, predicate);
//        builder.polymorphicType(MetadataFilter.class, predicate);
//        builder.polymorphicType(DocumentFilter.class, predicate);
//        builder.polymorphicType(DocumentProcessor.class, predicate);
//        builder.polymorphicType(MetadataChecksummer.class, predicate);
//        builder.polymorphicType(Committer.class, predicate);
//        builder.polymorphicType(DocumentChecksummer.class, predicate);
//        builder.polymorphicType(SpoiledReferenceStrategizer.class, predicate);
//        builder.polymorphicType(Fetcher.class, predicate);
//
//        //TODO add importer dynamically somehow?  Maybe by adding
//        // an unboundPropertyFactory, passing what it takes to load it?
//
//  }
}
