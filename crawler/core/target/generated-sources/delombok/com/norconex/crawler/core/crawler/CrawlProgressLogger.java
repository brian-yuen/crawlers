// Generated by delombok at Fri Mar 08 16:24:33 MST 2024
/* Copyright 2021-2023 Norconex Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.norconex.crawler.core.crawler;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.time.Duration;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.StopWatch;
import com.norconex.commons.lang.time.DurationFormatter;
import com.norconex.commons.lang.time.DurationUnit;
import com.norconex.crawler.core.monitor.CrawlerMonitor;

/**
 * Logs useful information about the crawler execution progress.
 */
class CrawlProgressLogger {
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(CrawlProgressLogger.class);
    private final StopWatch stopWatch = new StopWatch();
    private final Duration minLoggingInterval;
    private final CrawlerMonitor monitor;
    // Just so we can show the delta between each log entry
    private long prevProcessedCount;
    private long prevQueuedCount;
    private long prevElapsed;
    private final DurationFormatter durationFormatter = new DurationFormatter().withOuterLastSeparator(" and ").withOuterSeparator(", ").withUnitPrecision(2).withLowestUnit(DurationUnit.SECOND);
    private final NumberFormat intFormatter = NumberFormat.getIntegerInstance();

    // Minimum 1 second
    CrawlProgressLogger(CrawlerMonitor monitor, Duration minLoggingInterval) {
        this.monitor = monitor;
        prevProcessedCount = monitor.getProcessedCount();
        prevQueuedCount = monitor.getQueuedCount();
        if (minLoggingInterval != null && minLoggingInterval.getSeconds() < 0) {
            this.minLoggingInterval = Duration.ofSeconds(1);
        } else {
            this.minLoggingInterval = minLoggingInterval;
        }
    }

    void startTracking() {
        stopWatch.start();
    }

    void stopTracking() {
        stopWatch.stop();
    }

    // only log if logging was requested and enough time has elapsed.
    void logProgress() {
        // If not logging, return right away
        if (minLoggingInterval != null && LOG.isInfoEnabled()) {
            doLogProgress();
        }
    }

    String getExecutionSummary() {
        var elapsed = stopWatch.getTime();
        var processedCount = monitor.getProcessedCount();
        var b = new StringBuilder().append("\nTotal processed:   ").append(processedCount).append("\nSince (re)start:").append("\n  Crawl duration:  ").append(durationFormatter.format(elapsed)).append("\n  Avg. throughput: ").append(divideDownStr(processedCount * 1000, elapsed, 1)).append(" processed/seconds").append("\n  Event counts:");
        monitor.getEventCounts().entrySet().stream().forEach(en -> b.append("\n    ").append(StringUtils.rightPad(en.getKey() + ": ", 27)).append(intFormatter.format(en.getValue())));
        return b.toString();
    }

    synchronized void doLogProgress() {
        // If not enough time has elapsed, return
        var elapsed = stopWatch.getTime();
        if (elapsed < prevElapsed + minLoggingInterval.toMillis()) {
            return;
        }
        // OK, log it
        var processedCount = monitor.getProcessedCount();
        var queuedCount = monitor.getQueuedCount();
        var msg = infoMessage(elapsed, processedCount, queuedCount);
        if (LOG.isDebugEnabled()) {
            // if debugging, compute and show more stats
            LOG.info("{}{}", msg, debugMessage(elapsed, processedCount, queuedCount));
        } else {
            LOG.info(msg);
        }
        prevProcessedCount = processedCount;
        prevQueuedCount = queuedCount;
        prevElapsed = elapsed;
    }

    private String infoMessage(long elapsed, long processedCount, long queuedCount) {
        var processedDelta = plusMinus(processedCount - prevProcessedCount);
        var queuedDelta = plusMinus(queuedCount - prevQueuedCount);
        var elapsedTime = durationFormatter.format(stopWatch.getTime());
        var throughput = divideDownStr((processedCount - prevProcessedCount) * 1000, elapsed - prevElapsed, 1);
        return String.format("%s(%s) processed " + "| %s(%s) queued | %s processed/sec | %s elapsed", processedCount, processedDelta, queuedCount, queuedDelta, throughput, elapsedTime);
    }

    private String debugMessage(long elapsed, long processedCount, long queuedCount) {
        var totalSoFar = processedCount + queuedCount;
        var progress = divideDownStr(processedCount * 100, totalSoFar, 2);
        var remaining = durationFormatter.format(divideDown(elapsed * queuedCount, processedCount, 0).longValueExact());
        return String.format(" | ≈%s%% complete | ≈%s remaining", progress, remaining);
    }

    private String plusMinus(long val) {
        return (val >= 0 ? "+" : "") + intFormatter.format(val);
    }

    private BigDecimal divideDown(long dividend, long divisor, int scale) {
        if (divisor == 0L) {
            return BigDecimal.ZERO;
        }
        return BigDecimal.valueOf(dividend).divide(BigDecimal.valueOf(divisor), scale, RoundingMode.DOWN).stripTrailingZeros();
    }

    private String divideDownStr(long dividend, long divisor, int scale) {
        return divideDown(dividend, divisor, scale).toPlainString();
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public boolean equals(final java.lang.Object o) {
        if (o == this) return true;
        if (!(o instanceof CrawlProgressLogger)) return false;
        final CrawlProgressLogger other = (CrawlProgressLogger) o;
        if (!other.canEqual((java.lang.Object) this)) return false;
        if (this.prevProcessedCount != other.prevProcessedCount) return false;
        if (this.prevQueuedCount != other.prevQueuedCount) return false;
        if (this.prevElapsed != other.prevElapsed) return false;
        final java.lang.Object this$stopWatch = this.stopWatch;
        final java.lang.Object other$stopWatch = other.stopWatch;
        if (this$stopWatch == null ? other$stopWatch != null : !this$stopWatch.equals(other$stopWatch)) return false;
        final java.lang.Object this$minLoggingInterval = this.minLoggingInterval;
        final java.lang.Object other$minLoggingInterval = other.minLoggingInterval;
        if (this$minLoggingInterval == null ? other$minLoggingInterval != null : !this$minLoggingInterval.equals(other$minLoggingInterval)) return false;
        final java.lang.Object this$monitor = this.monitor;
        final java.lang.Object other$monitor = other.monitor;
        if (this$monitor == null ? other$monitor != null : !this$monitor.equals(other$monitor)) return false;
        final java.lang.Object this$durationFormatter = this.durationFormatter;
        final java.lang.Object other$durationFormatter = other.durationFormatter;
        if (this$durationFormatter == null ? other$durationFormatter != null : !this$durationFormatter.equals(other$durationFormatter)) return false;
        final java.lang.Object this$intFormatter = this.intFormatter;
        final java.lang.Object other$intFormatter = other.intFormatter;
        if (this$intFormatter == null ? other$intFormatter != null : !this$intFormatter.equals(other$intFormatter)) return false;
        return true;
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    protected boolean canEqual(final java.lang.Object other) {
        return other instanceof CrawlProgressLogger;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final long $prevProcessedCount = this.prevProcessedCount;
        result = result * PRIME + (int) ($prevProcessedCount >>> 32 ^ $prevProcessedCount);
        final long $prevQueuedCount = this.prevQueuedCount;
        result = result * PRIME + (int) ($prevQueuedCount >>> 32 ^ $prevQueuedCount);
        final long $prevElapsed = this.prevElapsed;
        result = result * PRIME + (int) ($prevElapsed >>> 32 ^ $prevElapsed);
        final java.lang.Object $stopWatch = this.stopWatch;
        result = result * PRIME + ($stopWatch == null ? 43 : $stopWatch.hashCode());
        final java.lang.Object $minLoggingInterval = this.minLoggingInterval;
        result = result * PRIME + ($minLoggingInterval == null ? 43 : $minLoggingInterval.hashCode());
        final java.lang.Object $monitor = this.monitor;
        result = result * PRIME + ($monitor == null ? 43 : $monitor.hashCode());
        final java.lang.Object $durationFormatter = this.durationFormatter;
        result = result * PRIME + ($durationFormatter == null ? 43 : $durationFormatter.hashCode());
        final java.lang.Object $intFormatter = this.intFormatter;
        result = result * PRIME + ($intFormatter == null ? 43 : $intFormatter.hashCode());
        return result;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public java.lang.String toString() {
        return "CrawlProgressLogger(stopWatch=" + this.stopWatch + ", minLoggingInterval=" + this.minLoggingInterval + ", monitor=" + this.monitor + ", prevProcessedCount=" + this.prevProcessedCount + ", prevQueuedCount=" + this.prevQueuedCount + ", prevElapsed=" + this.prevElapsed + ", durationFormatter=" + this.durationFormatter + ", intFormatter=" + this.intFormatter + ")";
    }
}
