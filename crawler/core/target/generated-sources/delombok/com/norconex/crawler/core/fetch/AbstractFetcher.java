// Generated by delombok at Fri Mar 08 16:24:33 MST 2024
/* Copyright 2022-2022 Norconex Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.norconex.crawler.core.fetch;

import java.util.Optional;
import com.norconex.commons.lang.config.Configurable;
import com.norconex.commons.lang.event.Event;
import com.norconex.commons.lang.event.EventListener;
import com.norconex.commons.lang.xml.XMLConfigurable;
import com.norconex.crawler.core.crawler.Crawler;
import com.norconex.crawler.core.crawler.CrawlerEvent;
import com.norconex.crawler.core.filter.FilterGroupResolver;
import com.norconex.crawler.core.filter.ReferenceFilter;
import com.norconex.crawler.core.session.CrawlSession;
import com.norconex.crawler.core.session.CrawlSessionEvent;
import com.norconex.importer.doc.Doc;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import lombok.NonNull;

/**
 * <p>
 * Base class implementing the {@link #accept(FetchRequest)} method
 * using reference filters to determine if this fetcher will accept to fetch
 * a document, in addition to whatever logic implementing classes may provide
 * by optionally overriding {@link #acceptRequest(FetchRequest)}
 * (which otherwise always return <code>true</code>).
 * It also offers methods to overwrite in order to react to crawler
 * startup and shutdown events.
 * </p>
 * <h3>XML configuration usage:</h3>
 * Subclasses inherit this {@link XMLConfigurable} configuration:
 *
 * {@nx.xml.usage #referenceFilters
 * <referenceFilters>
 *   <!-- multiple "filter" tags allowed -->
 *   <filter class="(any reference filter class)">
 *      (Restrict usage of this fetcher to matching reference filters.
 *       Refer to the documentation for the ReferenceFilter implementation
 *       you are using here for usage details.)
 *   </filter>
 * </referenceFilters>
 * }
 *
 * <h4>Usage example:</h4>
 * <p>
 * This XML snippet is an example of filter that restricts the application of
 * this Fetcher to references ending with ".pdf".
 * </p>
 *
 * {@nx.xml.example
 * <referenceFilters>
 *   <filter class="GenericReferenceFilter" onMatch="exclude">
 *     <valueMatcher method="regex">.*\.pdf$</valueMatcher>
 *   </filter>
 * </referenceFilters>
 * }
 *
 * @param <T> fetcher request type
 * @param <R> fetcher response type
 * @param <C> configuration type
 */
@XmlAccessorType(XmlAccessType.NONE)
public abstract class AbstractFetcher<T extends FetchRequest, R extends FetchResponse, C extends BaseFetcherConfig> implements Fetcher<T, R>, EventListener<Event>, Configurable<C> {
	@java.lang.SuppressWarnings("all")
	@lombok.Generated
	private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(AbstractFetcher.class);

	@Override
	public final boolean accept(@NonNull T fetchRequest) {
		java.util.Objects.requireNonNull(fetchRequest, "fetchRequest is marked non-null but is null");
		if (isAcceptedByReferenceFilters(fetchRequest) && acceptRequest(fetchRequest)) {
			LOG.debug("Fetcher {} ACCEPTED request \'{}\'.", getClass().getSimpleName(), fetchRequest);
			return true;
		}
		LOG.debug("Fetcher {} REJECTED request \'{}\'.", getClass().getSimpleName(), fetchRequest);
		return false;
	}

	/**
	 * Optional method for subclasses to override when in need for additional
	 * acceptance logic beyond reference filters (which this abstract class
	 * provides). This method is only invoked if there are no reference
	 * filters configured on this class, or all of them accepts the
	 * request document.
	 * Default implementation does nothing (always return <code>true</code>).
	 * @param fetchRequest the fetch request to evaluate
	 *     (never <code>null</code>)
	 * @return <code>true</code> if accepted
	 */
	protected boolean acceptRequest(@NonNull T fetchRequest) {
		java.util.Objects.requireNonNull(fetchRequest, "fetchRequest is marked non-null but is null");
		return true;
	}

	@Override
	public final void accept(Event event) {
		// Here we rely on session startup instead of
		// crawler startup to avoid being invoked multiple
		// times (once for each crawler)
		if (event.is(CrawlSessionEvent.CRAWLSESSION_RUN_BEGIN)) {
			fetcherStartup((CrawlSession) event.getSource());
		} else if (event.is(CrawlSessionEvent.CRAWLSESSION_RUN_END)) {
			fetcherShutdown((CrawlSession) event.getSource());
		} else if (event.is(CrawlerEvent.CRAWLER_RUN_THREAD_BEGIN) && Thread.currentThread().equals(((CrawlerEvent) event).getSubject())) {
			fetcherThreadBegin((Crawler) event.getSource());
		} else if (event.is(CrawlerEvent.CRAWLER_RUN_THREAD_END) && Thread.currentThread().equals(((CrawlerEvent) event).getSubject())) {
			fetcherThreadEnd((Crawler) event.getSource());
		}
	}

	/**
	 * Invoked once per fetcher instance, when the collector starts.
	 * Default implementation does nothing.
	 * @param collector collector
	 */
	protected void fetcherStartup(CrawlSession collector) {
		//NOOP
	}

	/**
	 * Invoked once per fetcher when the collector ends.
	 * Default implementation does nothing.
	 * @param collector collector
	 */
	protected void fetcherShutdown(CrawlSession collector) {
		//NOOP
	}

	/**
	 * Invoked each time a crawler begins a new crawler thread if that thread
	 * is the current thread.
	 * Default implementation does nothing.
	 * @param crawler crawler
	 */
	protected void fetcherThreadBegin(Crawler crawler) {
		//NOOP
	}

	/**
	 * Invoked each time a crawler ends an existing crawler thread if that
	 * thread is the current thread.
	 * Default implementation does nothing.
	 * @param crawler crawler
	 */
	protected void fetcherThreadEnd(Crawler crawler) {
		//NOOP
	}

	private boolean isAcceptedByReferenceFilters(@NonNull T fetchRequest) {
		java.util.Objects.requireNonNull(fetchRequest, "fetchRequest is marked non-null but is null");
		var ref = Optional.ofNullable(fetchRequest.getDoc()).map(Doc::getReference).orElse(null);
		return FilterGroupResolver.<ReferenceFilter>builder().filterResolver(f -> f.acceptReference(ref)).onAccepted(f -> LOG.debug("Fetcher {} ACCEPTED reference: \'{}\'. Filter={}", getClass().getSimpleName(), ref, f)).onRejected(f -> LOG.debug("Fetcher {} REJECTED reference: \'{}\'. Filter={}", getClass().getSimpleName(), ref, f)).onRejectedNoInclude(f -> LOG.debug("Fetcher {} REJECTED reference: \'{}\'. " + "No \'include\' filters matched.", getClass().getSimpleName(), ref)).build().accepts(getConfiguration().getReferenceFilters());
	}

	@java.lang.Override
	@java.lang.SuppressWarnings("all")
	@lombok.Generated
	public boolean equals(final java.lang.Object o) {
		if (o == this) return true;
		if (!(o instanceof AbstractFetcher)) return false;
		final AbstractFetcher<?, ?, ?> other = (AbstractFetcher<?, ?, ?>) o;
		if (!other.canEqual((java.lang.Object) this)) return false;
		return true;
	}

	@java.lang.SuppressWarnings("all")
	@lombok.Generated
	protected boolean canEqual(final java.lang.Object other) {
		return other instanceof AbstractFetcher;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings("all")
	@lombok.Generated
	public int hashCode() {
		final int result = 1;
		return result;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings("all")
	@lombok.Generated
	public java.lang.String toString() {
		return "AbstractFetcher()";
	}
}
