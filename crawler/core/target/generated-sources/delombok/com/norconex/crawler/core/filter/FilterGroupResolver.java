// Generated by delombok at Fri Mar 08 16:24:33 MST 2024
/* Copyright 2022 Norconex Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.norconex.crawler.core.filter;

import java.util.Collection;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * Resolves a group of filters, marking the group as accepted
 * (<code>true</code>) if All following conditions are met:
 *
 * <ul>
 *   <li>
 *     All filters NOT implementing {@link OnMatchFilter} return
 *     <code>true</code>.
 *   </li>
 *   <li>
 *     All filters implementing {@link OnMatchFilter} and set
 *     to {@link OnMatch#EXCLUDE} return <code>false</code>.
 *   </li>
 *   <li>
 *     If there is at least one filter implementing {@link OnMatchFilter}
 *     set to {@link OnMatch#INCLUDE}, then at least of those "include"
 *     filters must return <code>true</code>.
 *   </li>
 * </ul>
 * @param <T> filter type
 */
public class FilterGroupResolver<T> {
    private final Predicate<T> filterResolver;
    private Consumer<T> onAccepted;
    private Consumer<T> onRejected;
    private Consumer<Collection<T>> onRejectedNoInclude;

    public boolean accepts(Collection<T> filters) {
        return !isRejected(filters);
    }

    private boolean isRejected(Collection<T> filters) {
        var hasIncludes = false;
        var atLeastOneIncludeMatch = false;
        for (T filter : filters) {
            var accepted = filterResolver.test(filter);
            // Deal with includes
            if (isIncludeFilter(filter)) {
                hasIncludes = true;
                if (accepted) {
                    atLeastOneIncludeMatch = true;
                }
                continue;
            }
            // Deal with exclude and non-OnMatch filters
            if (!accepted) {
                Optional.ofNullable(onRejected).ifPresent(c -> c.accept(filter));
                return true;
            }
            Optional.ofNullable(onAccepted).ifPresent(c -> c.accept(filter));
        }
        if (hasIncludes && !atLeastOneIncludeMatch) {
            Optional.ofNullable(onRejectedNoInclude).ifPresent(c -> c.accept(filters));
            return true;
        }
        return false;
    }

    private static boolean isIncludeFilter(Object filter) {
        return filter instanceof OnMatchFilter f && OnMatch.INCLUDE == f.getOnMatch();
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    FilterGroupResolver(final Predicate<T> filterResolver, final Consumer<T> onAccepted, final Consumer<T> onRejected, final Consumer<Collection<T>> onRejectedNoInclude) {
        this.filterResolver = filterResolver;
        this.onAccepted = onAccepted;
        this.onRejected = onRejected;
        this.onRejectedNoInclude = onRejectedNoInclude;
    }


    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public static class FilterGroupResolverBuilder<T> {
        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        private Predicate<T> filterResolver;
        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        private Consumer<T> onAccepted;
        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        private Consumer<T> onRejected;
        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        private Consumer<Collection<T>> onRejectedNoInclude;

        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        FilterGroupResolverBuilder() {
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        public FilterGroupResolver.FilterGroupResolverBuilder<T> filterResolver(final Predicate<T> filterResolver) {
            this.filterResolver = filterResolver;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        public FilterGroupResolver.FilterGroupResolverBuilder<T> onAccepted(final Consumer<T> onAccepted) {
            this.onAccepted = onAccepted;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        public FilterGroupResolver.FilterGroupResolverBuilder<T> onRejected(final Consumer<T> onRejected) {
            this.onRejected = onRejected;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        public FilterGroupResolver.FilterGroupResolverBuilder<T> onRejectedNoInclude(final Consumer<Collection<T>> onRejectedNoInclude) {
            this.onRejectedNoInclude = onRejectedNoInclude;
            return this;
        }

        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        public FilterGroupResolver<T> build() {
            return new FilterGroupResolver<T>(this.filterResolver, this.onAccepted, this.onRejected, this.onRejectedNoInclude);
        }

        @java.lang.Override
        @java.lang.SuppressWarnings("all")
        @lombok.Generated
        public java.lang.String toString() {
            return "FilterGroupResolver.FilterGroupResolverBuilder(filterResolver=" + this.filterResolver + ", onAccepted=" + this.onAccepted + ", onRejected=" + this.onRejected + ", onRejectedNoInclude=" + this.onRejectedNoInclude + ")";
        }
    }

    @java.lang.SuppressWarnings("all")
    @lombok.Generated
    public static <T> FilterGroupResolver.FilterGroupResolverBuilder<T> builder() {
        return new FilterGroupResolver.FilterGroupResolverBuilder<T>();
    }
}
